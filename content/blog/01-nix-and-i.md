+++
title = "01 Nix and I"
date = "2025-12-13T02:53:35-06:00"

draft = true
description = "My experience with and thoughts on my favorite distro."
[params]
  author = 'Stell'

tags = ["myself","nix", "linux"]
+++

## My experience with Nix

I've been daily driving NixOS on my laptop since June 2025. My previous laptop was running Windows 11, then Ubuntu when Windows decided to be Windows. After that system broke (I dropped it), I had to buy a new laptop and decided it was also time for me to go distro hopping. While I'd been happy on Ubuntu and knew it well, I also had one glaring issue: packages.

`apt` isn't well known for having a bunch of fresh-off-the-PR-merge packages available to install. Ubuntu specifically also had me deal with the Snap store, which I didn't like at all. Why should I have to deal with an entirely separate marketplace just to get Firefox installed, especially one that sucked. Flatpak solved a few problems for me, but I didn't like the idea of having to add yet another package manager to my already convoluted system. Appimages frustrated me with how manual they were, especially for a program such as Discord which shipped updates frequently. Combined with an install of QT Design Studio I couldn't seem to get rid of, I no longer felt that I had a complete understanding and control of my system. The cord had become too tangled and Gordian in nature, and had to be cut. Breaking my already failing little Hewlett-Packard was the blade to do so.

What introduced me to and sold me on NixOS was a [video by No Boilerplate](https://youtu.be/CwfKlX3rA6E?si=EPSb2YtQHs710WTP), which adressed ever single one of the problems I'd been facing. Before that, I was considering using Arch, by the way, or perhaps one of its derivative distros like CachyOS or Manjaro. Learning that nixpkgs had not only more packages, but fresher ones at that than the AUR completely dwarfed the Nix learning curve I'd heard about. When my new Thinkpad T14 Gen 5 arrived, I spent about 10 total minutes in the pre-installed Windows environment solely to create an installer image for NixOS. I promptly washed my hands after the encounter.

Going straight to NixOS on baremetal actually seems to be a little uncommon now that I've spent more time in the community, so I'm quite proud that my experience was a good one. I was pretty quick to wrap my head around the basics of the Nix language and what my `configuration.nix` was doing. Making use of a modified version of `0atman`'s rebuild script was a lifesaver. Speeding up the time it took me to iterte through another Nix generation, even if it was just adding a few packages, made the whole experience lightyears better than what I'd been dealing with before.

## Thoughts on Nix and its future 

I liked the guarantees presented by using NixOS, which I refer to as the "Nix Promises": Immutability, Reproducibility, Reliability, enough to get past the hurdle that is using Nix. Even though NixOS isn't *truly* immutable by default, it gains a lot of the benefits from playing in that space via the `/nix/store/` directory. The reproducibility hasn't been something I've used all that much yet, but I'm excited to explore it as soon as I get my hands on some more hardware. The reliability has been the biggest strength of choosing NixOS as my operating system, and it's something I think the community would do well to emphasize.

Like with my favorite programming language, Rust, I think the Nix community often forgets some of the tool's greatest strenghts that would help push adoption. Actually, I think that Rust and Nix are both facets of the same kind of object, and not just because of how big of an overlap in the userbase there is, or the fact that they work well together. Rust and Nix set out to solve a class of problems that can really mess things up, by strictly enforcing and maintaining a certain amount of theoretical correctness that most don't really care about. The Rust borrow checker and packaging binaries with Nix both offer some overhead for their invariants that programmers just starting out with either often clash with. When speaking to people I know in person who haven't really interacted or heard of either, I often run into the shared question of "but why tho". And it's hard to answer! Why would someone bother with Rust and Nix when C++ and Ubuntu have served just fine. Nix especially, which isn't as well known as Rust, has a big problem with lacking a clear raison d'Ãªtre, which Rust does have. If you want low-level performance, like C, that's memory without the overhead of a garbage collector, you use Rust. It's simple, it's clear, and it gives people the motivation to actually use Rust without relying on the intellectual curiosity many use to climb up the learning curve. Yes Rust is "blazingly fast", but it isn't the clear leader by orders of magnitude. C and properly written C++ can even be faster by a few miliseconds, albeit at the loss of guaranteed memory safety compared to garbage collected languages. Speaking of which, people rarely want to manage their own memory. Go, Java, Python, etc are all used for one reason or another, and for many they're "fast enough". In the same way, other operating systems are "good enough" for most. NixOS is a minority within the minority that is Linux as a PC operatin system. Even ignoring the fact that Windows and MacOS all dwarf Linux's numbers, there are plenty of alternatives that someone might choose instead of Nix: Ubuntu, Fedora, Arch. NixOS lacks the same "default choice" that Rust has, or at least the criteria that make it a default choice are too narrow. If one were only looking for the Nix Promises, like I was, well then Nix *is* the obvious choice. However, the Nix Tradeoffs are something that I was willing to deal with in exchange for the Promises.
