+++
title = "01 Nix and I"
date = "2025-12-17"

description = "My experience with and thoughts on my favorite distro."
[params]
  author = 'Stell'

tags = ["myself","nix", "linux"]
+++

## My experience with Nix

I've been daily driving NixOS on my laptop since June 2025. My previous laptop was running Windows 11, then Ubuntu when Windows decided to be Windows. After that system broke (I dropped it), I had to buy a new laptop and decided it was also time for me to go distro hopping. While I'd been happy on Ubuntu and knew it well, I also had one glaring issue: packages.

`apt` isn't well known for having a bunch of fresh-off-the-PR-merge packages available to install. Ubuntu specifically also had me deal with the Snap store, which I didn't like at all. Why should I have to deal with an entirely separate marketplace just to get Firefox installed, especially one that sucked. Flatpak solved a few problems for me, but I didn't like the idea of having to add yet another package manager to my already convoluted system. Appimages frustrated me with how manual they were, especially for a program such as Discord which shipped updates frequently. Combined with an install of QT Design Studio I couldn't seem to get rid of, I no longer felt that I had a complete understanding and control of my system. The cord had become too tangled and Gordian in nature, and it had to be cut. Breaking my already failing little Hewlett-Packard was the blade to do so.

What introduced me to and sold me on NixOS was a [video by No Boilerplate](https://youtu.be/CwfKlX3rA6E?si=EPSb2YtQHs710WTP), which adressed ever single one of the problems I'd been facing. Before that, I was considering using Arch, by the way, or perhaps one of its derivative distros like CachyOS or Manjaro. Learning that nixpkgs had not only more packages, but fresher ones at that than the AUR completely dwarfed the Nix learning curve I'd heard about. When my new Thinkpad T14 Gen 5 arrived, I spent about 10 total minutes in the pre-installed Windows environment solely to create an installer image for NixOS. I promptly washed my hands after the encounter.

Going straight to NixOS on baremetal actually seems to be a little uncommon now that I've spent more time in the community, so I'm quite proud that my experience was a good one. I was pretty quick to wrap my head around the basics of the Nix language and what my `configuration.nix` was doing. Making use of a heavily modified version of `0atman`'s rebuild script was a lifesaver. Speeding up the time it took me to iterte through another Nix generation, even if it was just adding a few packages, made the whole experience lightyears better than what I'd been dealing with before.

## Thoughts on Nix and its future 

I liked the guarantees presented by using NixOS, which I refer to as the "Nix Promises": Immutability, Reproducibility, Reliability, enough to get past the hurdle that is using Nix. Even though NixOS isn't *truly* immutable by default, it gains a lot of the benefits from playing in that space via the `/nix/store/` directory. The reproducibility hasn't been something I've used all that much yet, but I'm excited to explore it as soon as I get my hands on some more hardware. The reliability has been the biggest strength of choosing NixOS as my operating system, and it's something I think the community would do well to emphasize.

Like with my favorite programming language, Rust, I think the Nix community often forgets some of the tool's greatest strenghts that would help push adoption. Actually, I think that Rust and Nix are both facets of the same kind of object, and not just because of how big of an overlap in the userbase there is, or the fact that they work well together. Rust and Nix set out to solve a class of problems that can really mess things up by strictly enforcing and maintaining a certain amount of theoretical correctness that most don't really care about. The Rust borrow checker and packaging binaries with Nix both offer some overhead for their invariants that programmers just starting out with either often clash with. When speaking to people I know in person who haven't really interacted or heard of either, I often run into the shared question of "but why tho". And it's hard to answer! Why would someone bother with Rust and Nix when C++ and Ubuntu have served just fine. Nix  has a big problem with lacking a clear raison d'Ãªtre, which Rust does have. Yes Rust can be "blazingly fast", but other languages are often fast enough and easier for most applications that citing its speed as its main strength isn't enough. But if you want low-level performance, like C, that's memory safe without the overhead of a garbage collector, you use Rust. It's simple, it's clear, and it gives people the motivation to actually use Rust without relying on the intellectual curiosity many use to climb up the learning curve. It's why Rust is a permanent part of the Linux kernel, when no other language has ever been added after it was originally written in C. In the same way, other operating systems are "good enough" for most. NixOS is a minority within the minority that is Linux as a PC operating system. Even ignoring the fact that Windows and MacOS all dwarf Linux's numbers, there are plenty of alternatives that someone might choose instead of Nix: Ubuntu, Fedora, Arch. NixOS lacks the same "default choice" that Rust has, or at least the criteria that make it a default choice are too narrow. If one were only looking for the Nix Promises, like I was, well then Nix *is* the obvious choice. However, the Nix Tradeoffs are something that I was willing to deal with in exchange for the Promises. That simply isn't true for everyone, and if Nix is going to grow its numbers and its ecosystem, it needs to be the best and hopefully only logical choice for a certain problem that people actually encounter, like Rust.

While thinking about its reliability, I realized that Nix is probably the best tool for "fire and forget" deployment for the space between general PCs and embedded systems that still needs to be user-customizable. Something where you really don't need to be doing much outside a specific usecase, but not so specific that you tailor and lock it down to one specific function as you do with an embedded system, and where it needs to work every single time. A kind of system where for whatever reason, you don't want it to ever break from a software bug. Update break your system at a critical time? Just roll back and deal with it when you're not depending on it. You get all of the benefit from the latest software, but you don't need to worry about your system breaking. As long as it works in your tests, it'll just work identically in production. 

Admittedly, I think this is a pretty small use case. Besides a personal project of mine that is nowhere near finished enough to share details about, I'm having a hard time thinking of a usecase for such a system that isn't already filled in by some kind of embedded system. Servers and hosting for large companies are the only other one I can really think of, and [Determinate Systems](https://determinate.systems/) seems to have already thought of this before me. Eelco Dolstra, the inventor of Nix, is one of its cofounders, so I'll be watching to see if Nix's adoption grows in that space over the next few years via their efforts. However, I personally would much prefer to see a growth in Nix's usage come from innovations brought about by its community, and not any single corporate entity, regardless who's a part of the corporation. Perhaps especially because of who's a part of the corporation.

I quite hope that Nix grows, not just because I like the technology, but because I think that Nix solves a lot of the problems inherent to the way we currently use computers and I because I believe that using Nix will make things easier. I personally am itching to help it get to this point. I need to figure out a lot about the lnguage and how packaging works, but I have a few programs I'm hoping to help get on Nixpkgs and become a contributor. Getting to where I am with only 6 months of experience at the time of writing feels like an extremely good place to be, and I imagine 6 months from now I'll be well beyond where I want to be when it comes to Nix.
